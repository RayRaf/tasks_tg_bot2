# Telegram Tasks Bot 2

**[@RaysNotifficationBot](https://t.me/RaysNotifficationBot)** – это вторая версия Telegram-бота для управления задачами. Новый бот был переработан с использованием Django и вебхуков, чтобы обеспечить более стабильную работу по сравнению с первой версией, где использовался метод поллинга.

Репозиторий проекта доступен по адресу: [https://github.com/RayRaf/tasks_tg_bot2.git](https://github.com/RayRaf/tasks_tg_bot2.git).

## Основные возможности

- **Управление задачами**:
  - Создание задач через Telegram.
  - Просмотр, редактирование и удаление задач через Telegram и веб-интерфейс.
  - Установка напоминаний на задачи.

- **Интеграция**:
  - Уникальные токенизированные ссылки для веб-доступа к задачам.
  - Веб-интерфейс для просмотра и редактирования задач.

- **Система уведомлений**:
  - Использование Celery и Redis для обработки фоновых задач и отправки напоминаний.

- **Оптимизация для продакшн-среды**:
  - Использование асинхронного сервера Uvicorn для высокой производительности.

## Что нового во второй версии?

- **Переход на Django и вебхуки**: Обеспечивает стабильность и скорость работы по сравнению с поллингом.
- **Адаптация для асинхронных операций**: Сервер Uvicorn обеспечивает надежную работу в продакшн-среде.
- **Улучшение архитектуры**: Гибкость и удобство разработки.
- **Масштабируемость**: Подходит для больших объемов данных и пользователей.

## Предыдущая версия бота

Первая версия бота, основанная на методе поллинга, доступна по адресу:  
[https://github.com/RayRaf/tasks_tg_bot](https://github.com/RayRaf/tasks_tg_bot).  

Эта версия проще в развертывании и использовании, но подходит для небольших проектов и имеет ограничения по стабильности из-за особенностей метода поллинга. Вы можете попробовать обе версии и выбрать ту, которая лучше подходит под ваши задачи.

## Требования

- Python 3.8+
- Docker
- Redis

## Установка

### 1. Клонирование репозитория

```bash
git clone https://github.com/RayRaf/tasks_tg_bot2.git
cd tasks_tg_bot2
```

### 2. Настройка переменных окружения

Создайте файл `.env` в корневой директории проекта и укажите следующие переменные:

```env
DJANGO_SECRET_KEY=ваш_секретный_ключ
TELEGRAM_TOKEN=ваш_токен_бота
REDIS_URL=redis://redis:6379/0
```

### 3. Сборка и запуск через Docker

```bash
docker-compose up --build
```

Эта команда запустит следующие сервисы:
- **Redis**: для управления очередями задач.
- **Web**: Django-приложение с поддержкой ASGI через Uvicorn.
- **Celery**: для обработки фоновых задач.
- **Celery Beat**: для планирования периодических задач.

### 4. Настройка вебхука Telegram

Укажите вебхук для вашего Telegram-бота, например:

```bash
curl -X POST "https://api.telegram.org/bot<ваш_токен_бота>/setWebhook" -d "url=https://ваш-домен.com/"
```

## Структура проекта

- **`docker-compose.yml`**: конфигурация сервисов для работы Redis, Django, Celery и Celery Beat.
- **`telegram.py`**: обработка команд и взаимодействия с пользователями через Telegram.
- **`urls.py`**: маршруты для веб-интерфейса.
- **`views.py`**: логика отображения и редактирования задач через токенизированные ссылки.
- **`urls_telegram.py`**: маршрут для вебхука Telegram.

## Использование

1. Взаимодействуйте с ботом через команды:
   - **Новая задача**: создание новой задачи.
   - **Список задач**: просмотр всех задач.
   - **Удалить задачу**: удаление определенной задачи.
   - **Установить время**: установка напоминания для задачи.
   - **Ссылка на веб**: получение уникальной ссылки на задачи.

2. Используйте веб-интерфейс для редактирования задач и управления напоминаниями.

## Разработка

### Запуск локально

Установите зависимости:

```bash
pip install -r requirements.txt
```

Запустите сервер разработки:

```bash
python manage.py runserver
```

### Запуск Celery локально

```bash
celery -A tasks_tg_bot2 worker --loglevel=info
```

### Запуск Celery Beat локально

```bash
celery -A tasks_tg_bot2 beat --loglevel=info
```

## Вклад в проект

Будем рады вашему участию! Открывайте issues или отправляйте pull requests в репозиторий [https://github.com/RayRaf/tasks_tg_bot2.git](https://github.com/RayRaf/tasks_tg_bot2.git) для обсуждения улучшений.

# Детали работы

## Описание механизма отправки уведомлений

Разберем последовательность выполнения задачи по уведомлению пользователя о времени задачи в данном проекте.

---

### Последовательность действий:

1. **Хранение задачи в базе данных**:
   - Каждая задача сохраняется в базе данных в таблице `tasks_task` (модель `Task` из `models.py`).
   - У задачи есть поля `reminder_time`, `reminder_set`, и `reminder_sent`, которые указывают:
     - Когда нужно отправить напоминание (`reminder_time`).
     - Активировано ли напоминание (`reminder_set`).
     - Отправлено ли напоминание (`reminder_sent`).

2. **Запуск периодической задачи с Celery-beat**:
   - Celery-beat добавляет задачу `send_notifications` в очередь Redis каждые 60 секунд, как указано в настройке `CELERY_BEAT_SCHEDULE`:
     ```python
     CELERY_BEAT_SCHEDULE = {
         'send-notifications-every-minute': {
             'task': 'tasks.tasks.send_notifications',
             'schedule': 60.0,  # каждые 60 секунд
         },
     }
     ```
   - Celery-beat только добавляет задачу в очередь и не выполняет её.

3. **Обработка задачи воркером Celery**:
   - Воркер Celery, запущенный в отдельном контейнере, извлекает задачу `send_notifications` из очереди Redis.
   - В коде эта задача определена в `tasks.py`:
     ```python
     @shared_task
     def send_notifications():
         now = timezone.now()
         tasks_to_notify = Task.objects.filter(
             reminder_set=True,
             reminder_sent=False,
             reminder_time__lte=now
         )
         for task in tasks_to_notify:
             if task.user.userprofile.chat_id:
                 chat_id = task.user.userprofile.chat_id
                 bot.send_message(chat_id, f"Напоминание: {task.text}")
                 task.reminder_sent = True
                 task.save()
     ```

4. **Извлечение задач из базы данных**:
   - При выполнении задачи `send_notifications` происходит запрос к базе данных (`Task.objects.filter(...)`), чтобы выбрать все задачи:
     - У которых включено напоминание (`reminder_set=True`).
     - Напоминание ещё не отправлено (`reminder_sent=False`).
     - Время напоминания уже наступило (`reminder_time__lte=now`).

5. **Отправка сообщения пользователю**:
   - Для каждой задачи, которая удовлетворяет критериям, определяется идентификатор чата (`chat_id`) через связь с `UserProfile`.
   - Бот отправляет сообщение с текстом задачи пользователю через Telegram API:
     ```python
     bot.send_message(chat_id, f"Напоминание: {task.text}")
     ```

6. **Обновление статуса задачи**:
   - После успешной отправки уведомления задача помечается как отправленная:
     ```python
     task.reminder_sent = True
     task.save()
     ```

---

### Схематическая последовательность:
1. **База данных**: Задача хранится с параметрами `reminder_time`, `reminder_set`, и `reminder_sent`.
2. **Celery-beat**: Периодически ставит задачу `send_notifications` в очередь Redis.
3. **Redis**: Хранит задачу, пока её не извлечёт воркер Celery.
4. **Celery-воркер**:
   - Извлекает задачу из Redis.
   - Делает запрос к базе данных, чтобы получить задачи для уведомления.
   - Отправляет сообщение через Telegram.
   - Обновляет статус задачи в базе данных.
5. **Пользователь**: Получает напоминание в Telegram.

---

### Почему это эффективно?
- **Асинхронность**: Проверка базы данных и отправка сообщений выполняются в фоне, не блокируя основной поток.
- **Масштабируемость**: Celery-воркеры можно запускать параллельно для обработки большого количества задач.
- **Надежность**: Если воркер или Redis временно недоступны, задачи остаются в очереди и обрабатываются при восстановлении.